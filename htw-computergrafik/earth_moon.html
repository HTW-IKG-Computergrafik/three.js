<!DOCTYPE html>
<html lang="en">

<head>
    <title>Three.js Webgl - Animation - Earth and Moon</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Earth and Moon
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
            {
                "imports": {
                    "three": "../build/three.module.js",
                    "three/addons/": "../examples/jsm/"
                }
            }
    </script>

    <script type="module">

        import * as THREE from 'three';

        let scene, camera, renderer;
        let earthMesh, moonMesh, berlinMesh, berlinLine;

        init();
        animate();

        function init() {

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 3, 5);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Earth sphere
            let radius = 1; // Earth's radius
            let earthGeometry = new THREE.SphereGeometry(1, 32, 32);
            let earthTexture = new THREE.TextureLoader().load('textures/earth_texture.jpg');
            earthTexture.offset.x = 0.33;
            let earthMaterial = new THREE.MeshPhongMaterial({ map: earthTexture });
            earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earthMesh);

            // Clouds
            let cloudGeometry = new THREE.SphereGeometry(1.01, 32, 32); // slightly larger than the Earth
            let cloudTexture = new THREE.TextureLoader().load('textures/clouds_texture.jpg');
            let cloudMaterial = new THREE.MeshPhongMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.5
            });
            let cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
            earthMesh.add(cloudMesh); // Add the cloud mesh as a child of earthMesh

            // Moon
            let moonGeometry = new THREE.SphereGeometry(0.27, 32, 32); // 0.27 is approximately 1/4 of Earth's size
            let moonTexture = new THREE.TextureLoader().load('textures/moon_texture.jpg');
            let moonMaterial = new THREE.MeshPhongMaterial({ map: moonTexture });
            moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            moonMesh.position.set(2, 0, 0); // position the moon
            scene.add(moonMesh);

            // Latitude and Longitude of Berlin, converted to radians
            let latitude = 52.5 * (Math.PI / 180);
            let longitude = 13.4 * (Math.PI / 180);

            // Berlin indicator
            let berlinGeometry = new THREE.ConeGeometry(0.11, 0.22, 32); 
            let berlinMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x990000 });
            let berlinSurfaceMesh = new THREE.Mesh(berlinGeometry, berlinMaterial);
            // create disc geometry for the base
            let discGeometry = new THREE.CircleGeometry(0.15, 32);
            let discTexture = new THREE.TextureLoader().load('textures/htw_berlin_logo.jpg');
            discTexture.flipY = false;  // Flip the texture
            let discMaterial = new THREE.MeshPhongMaterial({ map: discTexture, side: THREE.DoubleSide });
            let discMesh = new THREE.Mesh(discGeometry, discMaterial);

            // adjust position so it is at the base of the cone
            discMesh.position.y = -0.175;  // half the height of the cone

            // tilt the disc
            discMesh.rotation.x = - Math.PI / 3;  // tilt it 45 degrees

            // add the disc to the cone
            berlinSurfaceMesh.add(discMesh);
            berlinSurfaceMesh.position.x = -radius * Math.cos(latitude) * Math.sin(longitude);
            berlinSurfaceMesh.position.y = radius * Math.sin(latitude)+ 0.1;
            berlinSurfaceMesh.position.z = radius * Math.cos(latitude) * Math.cos(longitude);

            berlinSurfaceMesh.rotation.x = latitude + Math.PI;  // rotate to sit on surface and flip
            berlinSurfaceMesh.rotation.z = -longitude;  // rotate to sit on surface

            earthMesh.add(berlinSurfaceMesh);  // Add Berlin indicator to the Earth

            // // Adjust these for the position on Earth
            // berlinSurfaceMesh.position.x = -radius * Math.cos(latitude) * Math.sin(longitude);
            // berlinSurfaceMesh.position.y = radius * Math.sin(latitude);
            // berlinSurfaceMesh.position.z = radius * Math.cos(latitude) * Math.cos(longitude);

            // berlinSurfaceMesh.rotation.x = latitude;  // rotate to sit on surface
            // berlinSurfaceMesh.rotation.z = -longitude;  // rotate to sit on surface

            // earthMesh.add(berlinSurfaceMesh);  // Add Berlin indicator to the Earth



            // // Create a large sphere with a star background texture
            // let starGeometry = new THREE.SphereGeometry(1000, 64, 64);
            // let starTexture = new THREE.TextureLoader().load('../stars_texture.jpg');
            // let starMaterial = new THREE.MeshBasicMaterial({
            //     map: starTexture,
            //     side: THREE.BackSide
            // });
            // let starField = new THREE.Mesh(starGeometry, starMaterial);
            // scene.add(starField);



            // lights
            let light = new THREE.DirectionalLight(0xffffff, 1, 1000);
            light.position.set(100, 0, 0);
            scene.add(light);


            let ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {

            requestAnimationFrame(animate);
            // Adjust the initial rotation of the Earth so that longitude 0 (Greenwich, UK) is at the front

            earthMesh.rotation.y += 0.005;
            moonMesh.rotation.y += 0.005;

            moonMesh.position.x = 2 * Math.sin(Date.now() * 0.001); // Moon orbit
            moonMesh.position.z = 2 * Math.cos(Date.now() * 0.001); // Moon orbit

            renderer.render(scene, camera);
        }

    </script>

</body>

</html>